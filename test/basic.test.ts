import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { LastWinsAndCancelsPrevious } from "../src";

describe("LastWinsAndCancelsPrevious", () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it("—Ä–µ–∑–æ–ª–≤–∏—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–π –∑–∞–¥–∞—á–∏", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    expect(queue.result).toBeUndefined();
    const runResult = queue.run(async () => 42);
    expect(queue.result).not.toBeUndefined();
    const result = queue.result;
    expect(await runResult).toBe(42);
    expect(await result).toBe(42);
  });

  it("–æ—Ç–º–µ–Ω—è–µ—Ç –ø—Ä–µ–¥—ã–¥—É—â—É—é –∑–∞–¥–∞—á—É –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –Ω–æ–≤–æ–π", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    expect(queue.result).toBeUndefined();
    let firstAborted = false;
    const first = queue.run(async (signal) => {
      return new Promise<number>((resolve) => {
        signal.addEventListener("abort", () => {
          firstAborted = true;
          resolve(-1);
        });
        setTimeout(() => resolve(1), 100);
      });
    });
    const result = queue.result;
    expect(result).not.toBeUndefined();
    const second = queue.run(async () => 2);
    expect(queue.result).toBe(result);
    expect(await second).toBe(2);
    expect(await first).toBe(-1);
    expect(firstAborted).toBe(true);
    expect(await result).toBe(2);
  });

  it("run –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç undefined –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ –∑–∞–¥–∞—á–∏", async () => {
    const queue = new LastWinsAndCancelsPrevious<number | undefined>();
    expect(queue.result).toBeUndefined();
    const first = queue.run(async (signal) => {
      return new Promise<number | undefined>((resolve) => {
        signal.addEventListener("abort", () => resolve(undefined));
        setTimeout(() => resolve(1), 100);
      });
    });
    const result = queue.result;
    expect(result).not.toBeUndefined();
    const second = queue.run(async () => 2); // –æ—Ç–º–µ–Ω—è–µ—Ç –ø–µ—Ä–≤—É—é
    expect(queue.result).toBe(result);
    expect(await first).toBeUndefined();
    expect(await second).toBe(2);
    expect(await result).toBe(2);
  });

  it("result —Ä–µ–∑–æ–ª–≤–∏—Ç—Å—è —Ç–æ–ª—å–∫–æ —Å –ø–æ—Å–ª–µ–¥–Ω–µ–π –∑–∞–¥–∞—á–µ–π", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    expect(queue.result).toBeUndefined();
    queue.run(async () => 1);
    const result = queue.result;
    expect(queue.result).toBe(result);
    queue.run(async () => 2);
    expect(queue.result).toBe(result);
    const last = queue.run(async () => 3);
    expect(await last).toBe(3);
    expect(await result).toBe(3);
  });

  it("—Å—Ç–∞—Ä—ã–µ –∑–∞–¥–∞—á–∏ –±–µ–∑ AbortSignal –∑–∞–≤–µ—Ä—à–∞—é—Ç—Å—è, –Ω–æ –Ω–µ –≤–ª–∏—è—é—Ç –Ω–∞ result", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    expect(queue.result).toBeUndefined();
    let finished = false;
    const first = queue.run(async () => {
      await new Promise((r) => setTimeout(() => r("first"), 100));
      finished = true;
      return 1;
    });
    const result = queue.result;
    expect(result).not.toBeUndefined();
    const last = queue.run(async () => 2);
    expect(queue.result).toBe(result);
    await vi.advanceTimersByTimeAsync(100); // –ü—Ä–æ–¥–≤–∏–≥–∞–µ–º —Ç–∞–π–º–µ—Ä—ã, —á—Ç–æ–±—ã –ø—Ä–æ–º–∏—Å—ã —Ä–µ–∑–æ–ª–≤–∏–ª–∏—Å—å
    expect(await last).toBe(2);
    expect(await result).toBe(2);
    expect(await first).toBe(1); // –û–∂–∏–¥–∞–µ–º undefined, —Ç.–∫. –∑–∞–¥–∞—á–∞ –±—ã–ª–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞
    expect(finished).toBe(true);
  });

  it("–æ—à–∏–±–∫–∞ –≤ –∑–∞–¥–∞—á–µ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ reject result", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    expect(queue.result).toBeUndefined();
    const error = new Error("fail");
    const task = queue.run(async () => {
      throw error;
    });
    const result = queue.result;
    expect(result).not.toBeUndefined();
    await expect(task).rejects.toThrow("fail");
    await expect(result).rejects.toThrow("fail");
  });

  it("–ø–µ—Ä–≤–∞—è –∑–∞–¥–∞—á–∞ –ø–∞–¥–∞–µ—Ç —Å –æ—à–∏–±–∫–æ–π –î–û –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Ç–æ—Ä–æ–π ‚Äî result = task2, task1 —Ä–µ–¥–∂–µ–∫—Ç", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    let reject1: (e: any) => void, resolve2: (v: number) => void;
    const error1 = new Error("fail1");
    const task1 = queue.run(() => new Promise<number>((_, rej) => { reject1 = rej; }));
    const resultPromise = queue.result;
    const task2 = queue.run(() => new Promise<number>((res) => { resolve2 = res; }));
    reject1!(error1); // –ü–µ—Ä–≤–∞—è –∑–∞–¥–∞—á–∞ –ø–∞–¥–∞–µ—Ç —Å—Ä–∞–∑—É
    resolve2!(42);    // –í—Ç–æ—Ä–∞—è –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ
    expect(await task2).toBe(42);
    expect(await resultPromise).toBe(42);
    await expect(task1).rejects.toThrow("fail1");
  });

  it("–ø–µ—Ä–≤–∞—è –∑–∞–¥–∞—á–∞ –ø–∞–¥–∞–µ—Ç —Å –æ—à–∏–±–∫–æ–π –ü–û–°–õ–ï –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Ç–æ—Ä–æ–π ‚Äî result = task2, task1 —Ä–µ–¥–∂–µ–∫—Ç", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    let reject1: (e: any) => void, resolve2: (v: number) => void;
    const error1 = new Error("fail1");
    const task1 = queue.run(() => new Promise<number>((_, rej) => { reject1 = rej; }));
    const resultPromise = queue.result;
    const task2 = queue.run(() => new Promise<number>((res) => { resolve2 = res; }));
    resolve2!(42);    // –í—Ç–æ—Ä–∞—è –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –ø–µ—Ä–≤–æ–π
    reject1!(error1); // –ü–µ—Ä–≤–∞—è –∑–∞–¥–∞—á–∞ –ø–∞–¥–∞–µ—Ç –ø–æ—Å–ª–µ
    expect(await task2).toBe(42);
    expect(await resultPromise).toBe(42);
    await expect(task1).rejects.toThrow("fail1");
  });

  it("–µ—Å–ª–∏ –ø–µ—Ä–≤–∞—è –∑–∞–¥–∞—á–∞ —É–ø–∞–ª–∞ —Å –æ—à–∏–±–∫–æ–π, –Ω–æ –±—ã–ª–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞ –≤—Ç–æ—Ä–æ–π ‚Äî result = task2, task1 —Ä–µ–¥–∂–µ–∫—Ç", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    const error1 = new Error("fail1");
    let task1Reject: (e: any) => void;
    const task1 = queue.run(
      () =>
        new Promise<number>((_, reject) => {
          task1Reject = reject;
        })
    );
    task1.then((v) => console.log("üöÄ ~ it ~ v:", v)).catch((e) => console.log("üöÄ ~ it ~ e:", e));
    const resultPromise = queue.result;
    // –ó–∞–ø—É—Å–∫–∞–µ–º –≤—Ç–æ—Ä—É—é –∑–∞–¥–∞—á—É, –∫–æ—Ç–æ—Ä–∞—è —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è
    const task2 = queue.run(async () => 42);
    expect(resultPromise).toBe(queue.result);
    // –ü–µ—Ä–≤–∞—è –∑–∞–¥–∞—á–∞ –ø–∞–¥–∞–µ—Ç —Å –æ—à–∏–±–∫–æ–π, –Ω–æ —É–∂–µ –æ—Ç–º–µ–Ω–µ–Ω–∞
    task1Reject!(error1);
    expect(queue.result).toBe(resultPromise);
    console.log("üöÄ ~ it ~ task1:", task1);
    expect(await task2).toBe(42);
    expect(await resultPromise).toBe(42);
    await expect(task1).rejects.toThrow("fail1");
  });

  it("–≤—Ç–æ—Ä–∞—è –∑–∞–¥–∞—á–∞ –ø–∞–¥–∞–µ—Ç —Å –æ—à–∏–±–∫–æ–π –î–û –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–µ—Ä–≤–æ–π ‚Äî result –∏ task2 —Ä–µ–¥–∂–µ–∫—Ç, task1 success", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    let resolve1: (v: number) => void;
    const error2 = new Error("fail2");
    const task1 = queue.run(() => new Promise<number>((res) => { resolve1 = res; }));
    const resultPromise = queue.result;
    const task2 = queue.run(() => new Promise<number>((_, rej) => { rej(error2); }));
    // –í—Ç–æ—Ä–∞—è –∑–∞–¥–∞—á–∞ –ø–∞–¥–∞–µ—Ç –ø–µ—Ä–≤–æ–π
    await expect(task2).rejects.toThrow("fail2");
    resolve1!(1); // –ü–µ—Ä–≤–∞—è –∑–∞–¥–∞—á–∞ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ
    expect(await task1).toBe(1);
    await expect(resultPromise).rejects.toThrow("fail2");
  });

  it("–≤—Ç–æ—Ä–∞—è –∑–∞–¥–∞—á–∞ –ø–∞–¥–∞–µ—Ç —Å –æ—à–∏–±–∫–æ–π –ü–û–°–õ–ï –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–µ—Ä–≤–æ–π ‚Äî result –∏ task2 —Ä–µ–¥–∂–µ–∫—Ç, task1 success", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    let resolve1: (v: number) => void, reject2: (e: any) => void;
    const error2 = new Error("fail2");
    const task1 = queue.run(() => new Promise<number>((res) => { resolve1 = res; }));
    const resultPromise = queue.result;
    const task2 = queue.run(() => new Promise<number>((_, rej) => { reject2 = rej; }));
    resolve1!(1); // –ü–µ—Ä–≤–∞—è –∑–∞–¥–∞—á–∞ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è –ø–µ—Ä–≤–æ–π
    reject2!(error2); // –í—Ç–æ—Ä–∞—è –ø–∞–¥–∞–µ—Ç –ø–æ—Å–ª–µ
    expect(await task1).toBe(1);
    await expect(task2).rejects.toThrow("fail2");
    await expect(resultPromise).rejects.toThrow("fail2");
  });

  it("–µ—Å–ª–∏ –≤—Ç–æ—Ä–∞—è –∑–∞–¥–∞—á–∞ –ø–∞–¥–∞–µ—Ç —Å –æ—à–∏–±–∫–æ–π ‚Äî result –∏ task2 —Ä–µ–¥–∂–µ–∫—Ç, task1 success", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    const task1 = queue.run(async () => 1);
    const resultPromise = queue.result;
    // –í—Ç–æ—Ä–∞—è –∑–∞–¥–∞—á–∞ –ø–∞–¥–∞–µ—Ç
    const error2 = new Error("fail2");
    const task2 = queue.run(async () => {
      throw error2;
    });
    expect(queue.result).toBe(resultPromise);
    expect(await task1).toBe(1);
    await expect(task2).rejects.toThrow("fail2");
    await expect(resultPromise).rejects.toThrow("fail2");
  });

  it("–æ–±–µ –∑–∞–¥–∞—á–∏ –ø–∞–¥–∞—é—Ç: –ø–µ—Ä–≤–∞—è –î–û –≤—Ç–æ—Ä–æ–π ‚Äî result –∏ task2 —Ä–µ–¥–∂–µ–∫—Ç, task1 —Ä–µ–¥–∂–µ–∫—Ç", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    let reject1: (e: any) => void, reject2: (e: any) => void;
    const error1 = new Error("fail1");
    const error2 = new Error("fail2");
    const task1 = queue.run(() => new Promise<number>((_, rej) => { reject1 = rej; }));
    const resultPromise = queue.result;
    const task2 = queue.run(() => new Promise<number>((_, rej) => { reject2 = rej; }));
    reject1!(error1); // –ü–µ—Ä–≤–∞—è –ø–∞–¥–∞–µ—Ç –ø–µ—Ä–≤–æ–π
    reject2!(error2); // –í—Ç–æ—Ä–∞—è –ø–∞–¥–∞–µ—Ç –ø–æ—Å–ª–µ
    await expect(task1).rejects.toThrow("fail1");
    await expect(task2).rejects.toThrow("fail2");
    await expect(resultPromise).rejects.toThrow("fail2");
  });

  it("–æ–±–µ –∑–∞–¥–∞—á–∏ –ø–∞–¥–∞—é—Ç: –≤—Ç–æ—Ä–∞—è –î–û –ø–µ—Ä–≤–æ–π ‚Äî result –∏ task2 —Ä–µ–¥–∂–µ–∫—Ç, task1 —Ä–µ–¥–∂–µ–∫—Ç", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    let reject1: (e: any) => void, reject2: (e: any) => void;
    const error1 = new Error("fail1");
    const error2 = new Error("fail2");
    const task1 = queue.run(() => new Promise<number>((_, rej) => { reject1 = rej; }));
    const resultPromise = queue.result;
    const task2 = queue.run(() => new Promise<number>((_, rej) => { reject2 = rej; }));
    reject2!(error2); // –í—Ç–æ—Ä–∞—è –ø–∞–¥–∞–µ—Ç –ø–µ—Ä–≤–æ–π
    reject1!(error1); // –ü–µ—Ä–≤–∞—è –ø–∞–¥–∞–µ—Ç –ø–æ—Å–ª–µ
    await expect(task1).rejects.toThrow("fail1");
    await expect(task2).rejects.toThrow("fail2");
    await expect(resultPromise).rejects.toThrow("fail2");
  });

  it("–µ—Å–ª–∏ –æ–±–µ –∑–∞–¥–∞—á–∏ —É–ø–∞–ª–∏ —Å –æ—à–∏–±–∫–æ–π ‚Äî result –∏ task2 —Ä–µ–¥–∂–µ–∫—Ç, task1 —Ä–µ–¥–∂–µ–∫—Ç", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    const error1 = new Error("fail1");
    const error2 = new Error("fail2");
    const task1 = queue.run(async () => {
      throw error1;
    });
    const resultPromise = queue.result;
    const task2 = queue.run(async () => {
      throw error2;
    });
    expect(queue.result).toBe(resultPromise);
    await expect(task1).rejects.toThrow("fail1");
    await expect(task2).rejects.toThrow("fail2");
    await expect(resultPromise).rejects.toThrow("fail2");
  });

  it("concurrent: —Ç–æ–ª—å–∫–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–π –∑–∞–¥–∞—á–∏ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ result", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    expect(queue.result).toBeUndefined();
    let resolve1: (v: number) => void;
    let resolve2: (v: number) => void;
    let resolve3: (v: number) => void;
    const p1 = queue.run(
      () =>
        new Promise<number>((r) => {
          resolve1 = r;
        })
    );
    const result = queue.result;
    expect(result).not.toBeUndefined();
    const p2 = queue.run(
      () =>
        new Promise<number>((r) => {
          resolve2 = r;
        })
    );
    expect(queue.result).toBe(result);
    const p3 = queue.run(
      () =>
        new Promise<number>((r) => {
          resolve3 = r;
        })
    );
    expect(queue.result).toBe(result);
    resolve3!(33);
    expect(await p3).toBe(33);
    resolve1!(11);
    resolve2!(22);
    expect(await p1).toBe(11);
    expect(await p2).toBe(22);
    expect(await result).toBe(33);
  });
});

const wait = (ms: number) => new Promise((r) => setTimeout(r, ms));

// --- –¢–µ—Å—Ç—ã –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —Ä–µ–∑–æ–ª–≤–∞ result ---
describe("result consistency", () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });
  afterEach(() => {
    vi.useRealTimers();
  });

  it("result –Ω–µ —Ä–µ–∑–æ–ª–≤–∏—Ç—Å—è –¥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ run (–±–µ–∑ debounce/throttle)", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>();
    expect(queue.result).toBeUndefined();
    let resolve1: (v: number) => void;
    let resolve2: (v: number) => void;
    let resultResolved = false;
    const p1 = queue.run(
      () =>
        new Promise<number>((r) => {
          resolve1 = r;
        })
    );
    const result = queue.result;
    expect(result).not.toBeUndefined();
    const p2 = queue.run(
      () =>
        new Promise<number>((r) => {
          resolve2 = r;
        })
    );
    expect(queue.result).toBe(result);
    const resultPromise = queue.result!;
    resultPromise.then(() => {
      resultResolved = true;
    });
    // –ó–∞–≤–µ—Ä—à–∞–µ–º –ø–µ—Ä–≤—É—é –∑–∞–¥–∞—á—É ‚Äî result –Ω–µ –¥–æ–ª–∂–µ–Ω —Ä–µ–∑–æ–ª–≤–∏—Ç—å—Å—è
    expect(resultResolved).toBe(false);
    resolve1!(1);
    await Promise.resolve();
    expect(resultResolved).toBe(false);
    // –ó–∞–≤–µ—Ä—à–∞–µ–º –≤—Ç–æ—Ä—É—é (–ø–æ—Å–ª–µ–¥–Ω—é—é) –∑–∞–¥–∞—á—É ‚Äî —Ç–µ–ø–µ—Ä—å result –¥–æ–ª–∂–µ–Ω —Ä–µ–∑–æ–ª–≤–∏—Ç—å—Å—è
    resolve2!(2);
    await resultPromise;
    expect(resultResolved).toBe(true);
    expect(await resultPromise).toBe(2);
  });

  it("result –Ω–µ —Ä–µ–∑–æ–ª–≤–∏—Ç—Å—è –¥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ run (debounce trailing)", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>({ debounceMs: 300 });
    let resolveLast: (v: number) => void;
    let resultResolved = false;
    queue.run(() => new Promise<number>((r) => {}));
    const result = queue.result;
    result!.then(() => {
      resultResolved = true;
    });
    expect(result).not.toBeUndefined();
    queue.run(() => new Promise<number>((r) => {}));
    const lastPromise = queue.run(
      () =>
        new Promise<number>((r) => {
          resolveLast = r;
        })
    );
    expect(queue.result).toBe(result);
    vi.advanceTimersByTime(300); // –¢–æ–ª—å–∫–æ —Ç–µ–ø–µ—Ä—å –¥–µ–±–∞—É–Ω—Å –≤—ã–∑–æ–≤–µ—Ç –∑–∞–¥–∞—á—É
    await Promise.resolve();
    expect(resultResolved).toBe(false);
    resolveLast!(42);
    await lastPromise;
    expect(resultResolved).toBe(true);
    expect(await lastPromise).toBe(42);
    expect(await result).toBe(42);
  });

  it("result –Ω–µ —Ä–µ–∑–æ–ª–≤–∏—Ç—Å—è –¥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ run (throttle leading)", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>({
      throttleMs: 300,
      leading: true,
      trailing: false,
    });
    expect(queue.result).toBeUndefined();
    let resolve1: (v: number) => void;
    let resolve2: (v: number) => void;
    let resultResolved = false;
    const p1 = queue.run(
      () =>
        new Promise<number>((r) => {
          resolve1 = r;
        })
    );
    const result = queue.result;
    expect(result).not.toBeUndefined();
    result!.then(() => {
      resultResolved = true;
    });
    vi.advanceTimersByTime(350);
    const p2 = queue.run(
      () =>
        new Promise<number>((r) => {
          resolve2 = r;
        })
    );
    expect(queue.result).toBe(result);
    // –ó–∞–≤–µ—Ä—à–∞–µ–º –ø–µ—Ä–≤—É—é –∑–∞–¥–∞—á—É ‚Äî result –Ω–µ –¥–æ–ª–∂–µ–Ω —Ä–µ–∑–æ–ª–≤–∏—Ç—å—Å—è, —Ç.–∫. throttle –Ω–µ —Ä–∞–∑—Ä–µ—à–∏–ª –≤—Ç–æ—Ä—É—é
    resolve1!(1);
    await Promise.resolve();
    expect(resultResolved).toBe(false);
    // –¢–µ–ø–µ—Ä—å –∑–∞–≤–µ—Ä—à–∞–µ–º –≤—Ç–æ—Ä—É—é (–∫–æ—Ç–æ—Ä–∞—è –Ω–µ –¥–æ–ª–∂–Ω–∞ –±—ã–ª–∞ –±—ã—Ç—å –≤—ã–∑–≤–∞–Ω–∞)
    resolve2!(2);
    expect(await p1).toBe(1);
    expect(await p2).toBe(2);
    expect(await result).toBe(2);
  });

  it("result –Ω–µ —Ä–µ–∑–æ–ª–≤–∏—Ç—Å—è –¥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è trailing (throttle trailing)", async () => {
    const queue = new LastWinsAndCancelsPrevious<number>({
      throttleMs: 300,
      leading: false,
      trailing: true,
    });
    expect(queue.result).toBeUndefined();
    let resolveLast: (v: number) => void;
    let resultResolved = false;
    queue.run(() => new Promise<number>((r) => {}));
    const result = queue.result;
    expect(result).not.toBeUndefined();
    queue.run(() => new Promise<number>((r) => {}));
    expect(queue.result).toBe(result);
    const lastPromise = queue.run(
      () =>
        new Promise<number>((r) => {
          resolveLast = r;
        })
    );
    expect(queue.result).toBe(result);
    result!.then(() => {
      resultResolved = true;
    });
    vi.advanceTimersByTime(300); // –¢–æ–ª—å–∫–æ —Ç–µ–ø–µ—Ä—å throttle –≤—ã–∑–æ–≤–µ—Ç –∑–∞–¥–∞—á—É
    await Promise.resolve();
    expect(resultResolved).toBe(false);
    resolveLast!(99);
    await lastPromise;
    expect(resultResolved).toBe(true);
    expect(await lastPromise).toBe(99);
    expect(await result).toBe(99);
  });
});

describe("LastWinsAndCancelsPrevious ‚Äî debounce/throttle –ø–æ–≤–µ–¥–µ–Ω–∏–µ", () => {
  beforeEach(() => vi.useFakeTimers());
  afterEach(() => vi.useRealTimers());

  const makeTask =
    (value: number, log: number[], delay = 0) =>
    async () => {
      await wait(delay);
      log.push(value);
      return value;
    };

  it("debounce trailing=true (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é): –≤—ã–∑—ã–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –ø–∞—É–∑—ã", async () => {
    const log: number[] = [];
    const queue = new LastWinsAndCancelsPrevious<number>({ debounceMs: 300 });

    const r1 = queue.run(makeTask(1, log));
    const result = queue.result;
    vi.advanceTimersByTime(100);
    const r2 = queue.run(makeTask(2, log));
    vi.advanceTimersByTime(100);
    const r3 = queue.run(makeTask(3, log));
    vi.advanceTimersByTime(400);

    await vi.runAllTimersAsync();
    await vi.runAllTicks();
    expect(log).toEqual([3]);
    expect(await result).toBe(3);
    expect(await r1).toBeUndefined();
    expect(await r2).toBeUndefined();
    expect(await r3).toBe(3);
    expect(await result).toBe(3);
  });

  it("debounce leading=true: –≤—ã–∑—ã–≤–∞–µ—Ç —Å—Ä–∞–∑—É, –Ω–µ –≤ –∫–æ–Ω—Ü–µ", async () => {
    const log: number[] = [];
    const queue = new LastWinsAndCancelsPrevious<number>({
      debounceMs: 300,
      leading: true,
      trailing: false,
    });

    const r1 = queue.run(makeTask(1, log));
    const result = queue.result;
    vi.advanceTimersByTime(100);
    const r2 = queue.run(makeTask(2, log));
    vi.advanceTimersByTime(400);
    const r3 = queue.run(makeTask(3, log));
    vi.advanceTimersByTime(100);
    await vi.runAllTimersAsync();
    await vi.runAllTicks();
    await Promise.all([r1, r2, r3]);
    expect(await result).toBe(3);
    expect(await r1).toBe(1);
    expect(await r2).toBeUndefined();
    expect(await r3).toBe(3);
    expect(await result).toBe(3);
    expect(log).toEqual([1, 3]);
  });

  it("debounce leading + trailing: –≤—ã–∑—ã–≤–∞–µ—Ç –¥–≤–∞–∂–¥—ã ‚Äî –≤ –Ω–∞—á–∞–ª–µ –∏ –≤ –∫–æ–Ω—Ü–µ", async () => {
    const log: number[] = [];
    const queue = new LastWinsAndCancelsPrevious<number>({
      debounceMs: 300,
      leading: true,
      trailing: true,
    });

    const r1 = queue.run(makeTask(1, log));
    const result = queue.result;
    vi.advanceTimersByTime(100);
    const r2 = queue.run(makeTask(2, log));
    vi.advanceTimersByTime(200);
    const r3 = queue.run(makeTask(3, log));
    vi.advanceTimersByTime(400);

    await vi.runAllTicks();
    expect(log).toEqual([1, 3]);
    expect(await result).toBe(3);
    expect(await r1).toBe(1);
    expect(await r2).toBeUndefined();
    expect(await r3).toBe(3);
    expect(await result).toBe(3);
  });

  it("debounce leading=false, trailing=false: –Ω–µ –≤—ã–∑—ã–≤–∞–µ—Ç –Ω–∏—á–µ–≥–æ", async () => {
    const log: number[] = [];
    const queue = new LastWinsAndCancelsPrevious<number>({
      debounceMs: 300,
      leading: false,
      trailing: false,
    });

    const r1 = queue.run(makeTask(1, log));
    const r2 = queue.run(makeTask(1, log));
    const r3 = queue.run(makeTask(1, log));
    const r4 = queue.run(makeTask(1, log));
    vi.advanceTimersByTime(500);

    await vi.runAllTimersAsync();
    await vi.runAllTicks();
    expect(await r1).toBeUndefined();
    expect(log).toEqual([]);
  });

  it("throttle leading=true: –≤—ã–∑—ã–≤–∞–µ—Ç –æ–¥–∏–Ω —Ä–∞–∑ –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª", async () => {
    const log: number[] = [];
    const queue = new LastWinsAndCancelsPrevious<number>({
      throttleMs: 300,
      leading: true,
      trailing: false,
    });

    const r1 = queue.run(makeTask(1, log));
    vi.advanceTimersByTime(100);
    const r2 = queue.run(makeTask(2, log));
    vi.advanceTimersByTime(200);
    const r3 = queue.run(makeTask(3, log));
    vi.advanceTimersByTime(400);

    await vi.runAllTicks();
    const result = queue.result;
    expect(await result).toBe(3);
    expect(log).toEqual([1, 3]);
    expect(await r1).toBe(1);
    expect(await r2).toBeUndefined();
    expect(await r3).toBe(3);
    expect(await result).toBe(3);
  });

  it("throttle trailing=true: –≤—ã–∑—ã–≤–∞–µ—Ç –≤ –∫–æ–Ω—Ü–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞", async () => {
    const log: number[] = [];
    const queue = new LastWinsAndCancelsPrevious<number>({
      throttleMs: 300,
      leading: false,
      trailing: true,
    });

    const r1 = queue.run(makeTask(1, log));
    const result = queue.result;
    expect(result).not.toBeUndefined();
    vi.advanceTimersByTime(100);
    const r2 = queue.run(makeTask(2, log));
    expect(result).toBe(queue.result);
    vi.advanceTimersByTime(300);
    const r3 = queue.run(makeTask(3, log));
    expect(result).toBe(queue.result);
    vi.advanceTimersByTime(300);

    await vi.runAllTimersAsync();
    await vi.runAllTicks();
    expect(await result).toBe(3);
    expect(await r1).toBeUndefined();
    expect(await r2).toBe(2);
    expect(await r3).toBe(3);
    expect(await result).toBe(3);
    expect(log).toEqual([2, 3]);
  });

  it("throttle leading + trailing: –≤—ã–∑—ã–≤–∞–µ—Ç –¥–≤–∞–∂–¥—ã –Ω–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª", async () => {
    const log: number[] = [];
    const queue = new LastWinsAndCancelsPrevious<number>({
      throttleMs: 300,
      leading: true,
      trailing: true,
    });

    const r1 = queue.run(makeTask(1, log));
    vi.advanceTimersByTime(100);
    const r2 = queue.run(makeTask(2, log));
    vi.advanceTimersByTime(200);
    const r3 = queue.run(makeTask(3, log));
    vi.advanceTimersByTime(400);
    const r4 = queue.run(makeTask(4, log));
    const result = queue.result;
    expect(result).not.toBeUndefined();
    vi.advanceTimersByTime(400);

    await vi.runAllTimersAsync();
    await vi.runAllTicks();
    expect(await result).toBe(4);
    expect(await r1).toBe(1);
    expect(await r2).toBe(2);
    expect(await r3).toBe(3);
    expect(await r4).toBe(4);
    expect(await result).toBe(4);
    expect(log).toEqual([1, 2, 3, 4]);
  });

  it("throttle leading=false, trailing=false: –Ω–∏—á–µ–≥–æ –Ω–µ –≤—ã–∑—ã–≤–∞–µ—Ç", async () => {
    const log: number[] = [];
    const queue = new LastWinsAndCancelsPrevious<number>({
      throttleMs: 300,
      leading: false,
      trailing: false,
    });

    const r1 = await queue.run(makeTask(1, log));
    const r2 = await queue.run(makeTask(1, log));
    const r3 = await queue.run(makeTask(1, log));
    const r4 = await queue.run(makeTask(1, log));
    await vi.runAllTimersAsync();
    await vi.runAllTicks();
    expect(r1).toBeUndefined();
    expect(log).toEqual([]);
  });
});
